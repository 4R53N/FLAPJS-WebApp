<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/pda/graph/PDAGraph.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/pda/graph/PDAGraph.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import NodeGraph from 'graph/NodeGraph.js';
import PDANode from './PDANode.js';
import PDAEdge, { LINE_SEPARATOR } from './PDAEdge.js';

const PARALLEL_EDGE_HEIGHT = 10;

class PDAGraph extends NodeGraph
{
    constructor()
    {
        super(PDANode, PDAEdge);

        this._nodes = [];
    }

    setStartNode(node)
    {
        if (this._nodes.length &lt;= 0) throw new Error('Cannot set start node to empty graph');

        //There is only one node, and that is already the start node
        if (this._nodes.length === 1) return;

        const i = this._nodes.indexOf(node);
        if (i > 0)
        {
            //This does a swap; we could do a prepend but that's more costly...
            const prev = this._nodes[0];
            this._nodes[0] = node;
            this._nodes[i] = prev;
        }
        else if (i &lt; 0)
        {
            throw new Error('Cannot set start node for unknown node');
        }
    }

    getStartNode()
    {
        return this._nodes.length > 0 ? this._nodes[0] : null;
    }

    /** @override */
    addNode(node)
    {
        this._nodes.push(node);
        return super.addNode(node);
    }

    /** @override */
    deleteNode(node)
    {
        super.deleteNode(node);
        const i = this._nodes.indexOf(node);
        if (i >= 0) this._nodes.splice(i, 1);
    }

    /** @override */
    clearNodes()
    {
        super.clearNodes();
        this._nodes.length = 0;
    }

    //This is more like addEdge() without adding it to the graph and just returns the result
    //This should only be called once when completing an edge
    /** @override */
    formatEdge(edge)
    {
        const edgeSource = edge.getEdgeFrom();
        const edgeDestination = edge.getEdgeTo();
        const edgeLabel = edge.getEdgeLinesFromLabel();

        //Look for an existing edge with similar from and to
        for(const otherEdge of this.getEdges())
        {
            if (otherEdge === edge) continue;
            if (otherEdge.getEdgeFrom() === edgeSource &amp;&amp; otherEdge.getEdgeTo() === edgeDestination)
            {
                const otherLines = otherEdge.getEdgeLinesFromLabel();
                if (edgeLabel.length > 0)
                {
                    const result = otherLines.concat(edgeLabel);
                    otherEdge.setEdgeLabel(result.join(LINE_SEPARATOR));
                }

                //Merged with newfound edge...
                return otherEdge;
            }
        }

        //Otherwise, format the current edge

        if (!edge.isSelfLoop())
        {
            let flag = false;

            //Bend away if there is another edge not bent with the same src/dst
            const parallelEdgeHeight = PARALLEL_EDGE_HEIGHT;
            const HALFPI = Math.PI / 2;
            for(const otherEdge of this.getEdges())
            {
                if (otherEdge.isQuadratic() &amp;&amp; Math.abs(otherEdge.getQuadratic().length) >= parallelEdgeHeight * 2) continue;
                if ((otherEdge.getEdgeTo() === edgeSource &amp;&amp; otherEdge.getEdgeFrom() === edgeDestination))
                {
                    edge.setQuadraticRadians(HALFPI).setQuadraticLength(parallelEdgeHeight);
                    otherEdge.setQuadraticRadians(HALFPI).setQuadraticLength(parallelEdgeHeight);
                    flag = true;

                    //ASSUMES that there will only ever be 2 edges that are parallel...
                    break;
                }
            }

            //Try to move the edge away from intersecting nodes...
            if (!flag)
            {
                const maxNodeSize = Math.max(edgeSource.getNodeSize(), edgeDestination.getNodeSize());
                const x1 = edgeSource.x;
                const y1 = edgeSource.y;
                const x2 = edgeDestination.x;
                const y2 = edgeDestination.y;
                const dist12sq = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                let vertical = false;
                let m = 0;
                let b = 0;

                if(x1 > x2)
                {
                    m = (y1-y2) / (x1-x2);
                    b = y2-m*x2;
                }
                else if (x1 &lt; x2)
                {
                    m = (y2-y1) / (x2-x1);
                    b = y1-m*x1;
                }
                else
                {
                    vertical = true;
                }

                for(const node of this._nodes)
                {
                    if(node === edgeSource || node === edgeDestination) continue;

                    const x0 = node.x;
                    const y0 = node.y;

                    const dist01sq = (x1-x0)*(x1-x0) + (y1-y0)*(y1-y0);
                    const dist02sq = (x2-x0)*(x2-x0) + (y2-y0)*(y2-y0);
                    if(dist01sq > dist12sq || dist02sq > dist12sq) continue;

                    let dist = 0;
                    if(vertical) 
                    {
                        dist = Math.abs(x1-x0);
                    }
                    else 
                    {
                        dist = Math.abs(b+ m*x0 - y0) / Math.sqrt(1+m*m);
                    }

                    if(dist &lt; node.getNodeSize())
                    {
                        flag = true;
                        break;
                    }
                }

                if (flag)
                {
                    edge.setQuadraticRadians(-Math.PI / 2);
                    edge.setQuadraticLength(maxNodeSize + 10);
                }
            }
        }

        return edge;
    }
}

export default PDAGraph;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GraphEdge.html">GraphEdge</a></li><li><a href="GraphEditorView.html">GraphEditorView</a></li><li><a href="GraphElement.html">GraphElement</a></li><li><a href="GraphNode.html">GraphNode</a></li><li><a href="JFLAPGraphParser.html">JFLAPGraphParser</a></li><li><a href="NodeGraph.html">NodeGraph</a></li><li><a href="QuadraticEdge.html">QuadraticEdge</a></li><li><a href="SemanticVersion.html">SemanticVersion</a></li><li><a href="StateNotificationLayout.html">StateNotificationLayout</a></li></ul><h3>Global</h3><ul><li><a href="global.html#doesSupportLocalStorage">doesSupportLocalStorage</a></li><li><a href="global.html#getCurrentURL">getCurrentURL</a></li><li><a href="global.html#getDirectionalVector">getDirectionalVector</a></li><li><a href="global.html#getFileExtFromName">getFileExtFromName</a></li><li><a href="global.html#getMidPoint">getMidPoint</a></li><li><a href="global.html#getURLParameters">getURLParameters</a></li><li><a href="global.html#guid">guid</a></li><li><a href="global.html#lerp">lerp</a></li><li><a href="global.html#loadMachineFromData">loadMachineFromData</a></li><li><a href="global.html#stringHash">stringHash</a></li><li><a href="global.html#uuid">uuid</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.1</a> on Wed May 15 2019 21:55:29 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/fsa2/tester/StringTester.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/fsa2/tester/StringTester.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Eventable from 'util/Eventable.js';

import { solveFSAByStep } from 'modules/fsa2/machine/FSAUtils.js';

import TapeContext from './TapeContext.js';

class TestTapeContext extends TapeContext
{
    constructor(tester, graphController, machineController)
    {
        super(tester.getTestString(), false, true);

        this._tester = tester;
        this._graphController = graphController;
        this._machineController = machineController;
    }

    /** @override */
    stepForward()
    {
        const graphController = this._graphController;
        const machineController = this._machineController;
        this._tester.stepForward(graphController, machineController);
    }

    /** @override */
    stepBackward()
    {
        const graphController = this._graphController;
        const machineController = this._machineController;
        this._tester.stepBackward(graphController, machineController);
    }

    /** @override */
    reset()
    {
        this._tester.resetPosition();
    }

    /** @override */
    finish()
    {
        const graphController = this._graphController;
        const machineController = this._machineController;
        this._tester.runTest(graphController, machineController, false);
    }

    /** @override */
    stop()
    {
        this._tester.stopTest();
    }

    /** @override */
    changeTapeSymbol(index, symbol='')
    {
        throw new Error('Operation not yet supported');
    }

    /** @override */
    getTapeSourceStatesByIndex(index)
    {
        if (index &lt; 0 || index >= this._tapeInput.length) return null;
        return this._tester.getNodesAtPosition(index);
    }

    /** @override */
    getTapeSymbolByIndex(index)
    {
        if (index &lt; 0 || index >= this._tapeInput.length) return [];
        return this._tapeInput[index] || '';
    }

    /** @override */
    setCurrentTapeIndex(index)
    {
        this._tester.changePosition(index);
    }

    /** @override */
    getCurrentTapeIndex()
    {
        return this._tester.getPosition();
    }
}

class StringTester
{
    constructor()
    {
        this._testString = null;
        this._testIndex = -1;

        this._tapeContext = null;

        //For nfa solver use
        this._cachePath = [];
        this._cachedResult = null;
        this._resolve = null;
        this._reject = null;

        this.registerEvent('startTest');
        this.registerEvent('stepTest');
        this.registerEvent('stopTest');
    }

    //TODO: a hack to get current targets.
    get targets()
    {
        if (this._cachePath.length &lt;= 0) return [];
        const cache = this._cachePath[this._cachePath.length - 1];
        return cache.targets;
    }

    startTest(testString, graphController, machineController)
    {
        if (!testString) testString = '';
        if (this._tapeContext) throw new Error('Unable to start an already running test');

        const graph = graphController.getGraph();
        if (graph.isEmpty()) return Promise.reject();

        this._testString = testString;
        this._testIndex = -1;
        this._cachePath.length = 0;
        this._cachedResult = null;
        this._tapeContext = new TestTapeContext(this, graphController, machineController);

        this.emit('startTest', this);

        return new Promise((resolve, reject) => 
        {
            this._resolve = resolve;
            this._reject = reject;
        });
    }

    stopTest()
    {
        if (!this._tapeContext) throw new Error('Unable to stop null test');

        this.emit('stopTest', this);

        if (!this._resolve) throw new Error('Must call startTest() before anything else');
        if (!this._reject) throw new Error('Must call startTest() before anything else');

        let testResult = null;
        if (this._cachePath.length >= this._testString.length)
        {
            testResult = this._cachedResult;
            this._resolve(testResult);
        }
        else
        {
            testResult = null;
            this._reject();
        }

        this._testString = null;
        this._testIndex = -1;
        this._cachePath.length = 0;
        this._cachedResult = null;
        this._tapeContext = null;

        return Promise.resolve(testResult);
    }

    runTest(graphController, machineController, thenStop=false)
    {
        if (!this._tapeContext) throw new Error('Unable to run null test');

        return new Promise((resolve, reject) => 
        {
            let result = false;
            do
            {
                result = this.stepForward(graphController, machineController, !thenStop);
            }
            while (result);

            resolve(this._cachedResult);
        }).then((result) => 
        {
            if (thenStop) return this.stopTest();
            else return result;
        });
    }

    stepForward(graphController, machineController, cacheStep=true)
    {
        const machine = machineController.getMachineBuilder().getMachine();

        if (this._testIndex >= this._testString.length) return false;
        ++this._testIndex;

        if (this._cachePath.length &lt;= this._testIndex)
        {
            //Calculate current step...
            let cachedStates, cachedSymbols = null;
            const isResult = this._testIndex === this._testString.length;

            //Initialize first step...
            if (this._testIndex &lt;= 0)
            {
                cachedStates = [];
                cachedSymbols = [];

                const startState = machine.getStartState();
                for (const currentState of machine.doClosureTransition(startState))
                {
                    cachedStates.push({state: currentState, index: 0});
                }
            }
            else
            {
                const prevCache = this._cachePath[this._testIndex - 1];
                cachedStates = prevCache.states.slice();
                cachedSymbols = prevCache.symbols.slice();

                //Do the remaining steps...
                const nextSymbol = this._testString[this._testIndex - 1];
                solveFSAByStep(machine, nextSymbol, cachedStates, cachedSymbols);
            }

            //Do one last step for result...
            if (isResult)
            {
                this._cachedResult = solveFSAByStep(machine, null, cachedStates, cachedSymbols);
            }

            //Store current step...
            const targets = new Set();
            for(const cachedState of cachedStates)
            {
                const node = cachedState.state.getSource();

                //Couldn't find the node that was solved for this step...
                if (!node) throw new Error('Could not find node \'' + cachedState.state + '\'');

                targets.add(node);
            }
            const nextCache = {
                targets: Array.from(targets),
                states: cachedStates,
                symbols: cachedSymbols
            };
            this._cachePath.push(nextCache);
        }
        else
        {
            //Go forward a previously calculated step...by doing nothing...
        }

        this.emit('stepTest');
        return true;
    }

    stepBackward(graphController, machineController)
    {
        if (this._testIndex &lt;= 0) return false;
        --this._testIndex;

        //Go back a step...by doing nothing...
        this.emit('stepTest');
        return true;
    }

    isTesting()
    {
        return this._testString !== null;
    }

    changePosition(position)
    {
        if (position >= this._cachePath.length)
        {
            this._testIndex = this._cachePath.length - 1;
        }
        else
        {
            if (position &lt; 0)
            {
                this._testIndex = 0;
            }
            else if (position >= this._testString.length)
            {
                this._testIndex = this._testString.length - 1;
            }
            else
            {
                this._testIndex = position;
            }
        }
    }

    resetPosition()
    {
        this._testIndex = -1;
    }

    getPosition()
    {
        return this._testIndex;
    }

    isComputedPosition(position)
    {
        return this._cachePath.length > position;
    }

    getCurrentNodes()
    {
        if (this._testIndex >= 0 &amp;&amp; this._testIndex &lt; this._cachePath.length)
        {
            return this._cachePath[this._testIndex];
        }
        else
        {
            return null;
        }
    }

    getNodesAtPosition(position)
    {
        if (position >= 0 &amp;&amp; position &lt; this._cachePath.length)
        {
            return this._cachePath[position].targets;
        }
        else
        {
            return null;
        }
    }

    getTestString()
    {
        return this._testString;
    }

    getTapeContext()
    {
        return this._tapeContext;
    }
}
Eventable.mixin(StringTester);

export default StringTester;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GraphEdge.html">GraphEdge</a></li><li><a href="GraphEditorView.html">GraphEditorView</a></li><li><a href="GraphElement.html">GraphElement</a></li><li><a href="GraphNode.html">GraphNode</a></li><li><a href="JFLAPGraphParser.html">JFLAPGraphParser</a></li><li><a href="NodeGraph.html">NodeGraph</a></li><li><a href="QuadraticEdge.html">QuadraticEdge</a></li><li><a href="SemanticVersion.html">SemanticVersion</a></li><li><a href="StateNotificationLayout.html">StateNotificationLayout</a></li></ul><h3>Global</h3><ul><li><a href="global.html#doesSupportLocalStorage">doesSupportLocalStorage</a></li><li><a href="global.html#getCurrentURL">getCurrentURL</a></li><li><a href="global.html#getDirectionalVector">getDirectionalVector</a></li><li><a href="global.html#getFileExtFromName">getFileExtFromName</a></li><li><a href="global.html#getMidPoint">getMidPoint</a></li><li><a href="global.html#getURLParameters">getURLParameters</a></li><li><a href="global.html#guid">guid</a></li><li><a href="global.html#lerp">lerp</a></li><li><a href="global.html#loadMachineFromData">loadMachineFromData</a></li><li><a href="global.html#stringHash">stringHash</a></li><li><a href="global.html#uuid">uuid</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.1</a> on Wed May 15 2019 21:55:29 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

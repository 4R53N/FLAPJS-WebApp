/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/debug/Tester.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app/graph/GraphElement.js":
/*!***************************************!*\
  !*** ./src/app/graph/GraphElement.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass GraphElement\n{\n  constructor(id)\n  {\n    this._id = id;\n  }\n  \n  setGraphElementID(graphElementID)\n  {\n    this._id = graphElementID;\n    return this;\n  }\n\n  getGraphElementID()\n  {\n    return this._id;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (GraphElement);\n\n\n//# sourceURL=webpack:///./src/app/graph/GraphElement.js?");

/***/ }),

/***/ "./src/app/modules/fsa/machine/FSA.js":
/*!********************************************!*\
  !*** ./src/app/modules/fsa/machine/FSA.js ***!
  \********************************************/
/*! exports provided: State, Transition, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"State\", function() { return State; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Transition\", function() { return Transition; });\n/* harmony import */ var graph_GraphElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graph/GraphElement.js */ \"./src/app/graph/GraphElement.js\");\n/* harmony import */ var util_MathHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util/MathHelper.js */ \"./src/app/util/MathHelper.js\");\n\n\n\nconst FROM_STATE_INDEX = 0;\nconst SYMBOL_INDEX = 1;\nconst TO_STATE_INDEX = 2;\n\nclass State\n{\n  constructor(label=\"\", src=null)\n  {\n    this._label = label;\n\n    this._src = src;\n    this._id = src instanceof graph_GraphElement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] ? src.getGraphElementID() : Object(util_MathHelper_js__WEBPACK_IMPORTED_MODULE_1__[\"guid\"])();\n  }\n\n  copy()\n  {\n    const result = new State();\n    result._label = this._label;\n    result._src = this._src;\n    result._id = this._id;\n    return result;\n  }\n\n  getStateLabel() { return this._label; }\n\n  getStateID() { return this._id; }\n  getSource() { return this._src; }\n}\n\nclass Transition\n{\n  constructor(from, to, symbols=[])\n  {\n    this._from = from;\n    this._to = to;\n    this._symbols = symbols;\n  }\n\n  copy()\n  {\n    const result = new Transition();\n    result._from = this._from;\n    result._to = this._to;\n    result._symbols = this._symbols.slice();\n    return result;\n  }\n\n  getSourceState() { return this._from; }\n  getDestinationState() { return this._to; }\n\n  addSymbol(symbol) { this._symbols.push(symbol); }\n  hasSymbol(symbol) { return this._symbols.includes(symbol); }\n  getSymbols() { return this._symbols; }\n}\n\nclass FSA\n{\n  constructor(deterministic=false)\n  {\n    //state id -> state\n    this._states = new Map();\n    //symbol -> symbol use counter\n    this._alphabet = new Map();\n    //transition key (from + to) -> transition object\n    this._transitions = new Map();\n    this._finalStates = new Set();\n    this._customSymbols = new Set();\n    this._startState = null;\n\n    this._deterministic = deterministic;\n    this._errors = [];\n  }\n\n  /**\n   * Performs a shallow copy of the 2 machines. Any changes to a state will be\n   * reflected in both. However, changes to transitions, alphabet, and final\n   * states will not propagate.\n   */\n  copy(fsa)\n  {\n    //You are already yourself, don't copy nothing.\n    if (fsa === this) return;\n\n    //Make room for the copy...\n    this.clear();\n\n    //Copy state\n    for(const [key, value] of fsa._states.entries())\n    {\n      const result = value.copy();\n      this._states.set(key, result);\n\n      //Copy start state\n      if (fsa.isStartState(value))\n      {\n        this._startState = result;\n      }\n      //Copy final states\n      if (fsa.isFinalState(value))\n      {\n        this._finalStates.add(result);\n      }\n    }\n    //Copy alphabet\n    for(const [key, value] of fsa._alphabet.entries())\n    {\n      this._alphabet.set(key, value);\n    }\n    //Copy transitions\n    for(const [key, value] of fsa._transitions.entries())\n    {\n      const result = value.copy();\n      result._from = this._states.get(value.getSourceState().getStateID());\n      result._to = this._states.get(value.getDestinationState().getStateID());\n      this._transitions.set(key, result);\n    }\n    //Copy custom symbols\n    for(const symbol of fsa._customSymbols)\n    {\n      this._customSymbols.add(symbol);\n    }\n\n    //Copy determinism\n    this._deterministic = fsa._deterministic;\n\n    //Copy errors\n    for(const error of fsa._errors)\n    {\n    //WARNING: if the error's store state objects, they need to be redirected to the copies\n      this._errors.push(error);\n    }\n  }\n\n  clear()\n  {\n    this._states.clear();\n    this._alphabet.clear();\n    this._transitions.clear();\n    this._finalStates.clear();\n    this._customSymbols.clear();\n    this._startState = null;\n\n    this._errors.length = 0;\n  }\n\n  setDeterministic(deterministic) { this._deterministic = deterministic; }\n  isDeterministic() { return this._deterministic; }\n\n  validate()\n  {\n    //Reset errors\n    this._errors.length = 0;\n\n    if (this._deterministic)\n    {\n      const foundSymbols = new Map();\n      for(const key of this._alphabet.keys())\n      {\n        foundSymbols.set(key, false);\n      }\n\n      for(const state of this._states.values())\n      {\n        //Get all outgoing transitions\n        const transitions = this.getOutgoingTransitions(state);\n        for(const transition of transitions)\n        {\n          const symbol = transition[SYMBOL_INDEX];\n\n          //We don't need to worry about empty symbols cause this is a DFA\n          //So just assume every symbol is a valid one\n          if (!foundSymbols.get(symbol))\n          {\n            foundSymbols.set(symbol, true);\n          }\n          else\n          {\n            //Found duplicate\n            this._errors.push(\"duplicate symbol: \" + symbol);\n            return false;\n          }\n        }\n\n        //Reset foundSymbols for next state\n        for(const key of foundSymbols.keys())\n        {\n          if (!foundSymbols.get(key))\n          {\n            //Found missing symbol for state\n            this._errors.push(\"missing symbol: \" + key);\n            return false;\n          }\n\n          //Reset found symbol\n          foundSymbols.set(key, false);\n        }\n      }\n\n      //No errors found\n      this._errors.length = 0;\n      return true;\n    }\n    else\n    {\n      //It is a valid NFA already\n      this._errors.length = 0;\n      return true;\n    }\n  }\n  isValid() { return this._errors.length == 0; }\n  getErrors() { return this._errors; }\n\n  createState(label=\"\")\n  {\n    return this.addState(new State(label));\n  }\n\n  addState(state)\n  {\n    const stateID = state.getStateID();\n    if (this._states.has(stateID)) throw new Error(\"Already added state with id \\'\" + stateID + \"\\'\");\n    //Make state as new start state if no other states exist...\n    if (this._states.size <= 0) this._startState = state;\n    //Add to state set\n    this._states.set(stateID, state);\n    return state;\n  }\n\n  removeState(state)\n  {\n    const stateID = state.getStateID();\n    if (!this._states.has(stateID)) return false;\n    this._states.delete(stateID);\n\n    //Deleted the start state, so must pick another one...\n    if (this._startState === state)\n    {\n      if (this._states.size <= 0)\n      {\n        //If no more states to choose from, don't choose anything\n        this._startState = null;\n      }\n      else\n      {\n        //Choose an arbitrary start state\n        this._startState = this._states.values().next().value;\n      }\n    }\n\n    return true;\n  }\n\n  hasStateWithLabel(label)\n  {\n    for(const state of this._states.values())\n    {\n      if (state.getStateLabel() == label)\n      {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  getStatesByLabel(label, dst=[])\n  {\n    for(const state of this._states.values())\n    {\n      if (state.getStateLabel() == label)\n      {\n        dst.push(state);\n      }\n    }\n    return dst;\n  }\n\n  hasState(state) { return this._states.has(state.getStateID()); }\n\n  getStates() { return this._states.values(); }\n\n  addTransition(from, to, symbol)\n  {\n    if (!this.hasState(from)) throw new Error(\"Trying to add a transition to unknown state with label \\'\" + state.getStateLabel() + \"\\'\");\n    if (!this.hasState(to)) throw new Error(\"Trying to add a transition to unknown state with label \\'\" + state.getStateLabel() + \"\\'\");\n    if (!symbol) throw new Error(\"Cannot add transition for null symbol - use the empty symbol instead\");\n\n    const transitionKey = from.getStateID() + \"->\" + to.getStateID();\n    if (this._transitions.has(transitionKey))\n    {\n      const transition = this._transitions.get(transitionKey);\n      if (!transition.hasSymbol(symbol))\n      {\n        transition.addSymbol(symbol);\n      }\n      else\n      {\n        //Didn't add anything...\n        return false;\n      }\n    }\n    else\n    {\n      this._transitions.set(transitionKey, new Transition(from, to, [symbol]));\n    }\n\n    //Add to alphabet...\n    this._incrSymbolCount(symbol);\n    return true;\n  }\n\n  removeTransition(from, to, symbol=null)\n  {\n    const transitionKey = from.getStateID() + \"->\" + to.getStateID();\n    if (!this._transitions.has(transitionKey)) return false;\n\n    const transition = this._transitions.get(transitionKey);\n    const symbols = transition.getSymbols();\n\n    //If deleting a specific symbol...\n    if (symbol)\n    {\n      const index = symbols.indexOf(symbol);\n      if (index >= 0)\n      {\n        //Update symbol counts...\n        this._decrSymbolCount(symbol);\n\n        symbols.splice(index, 1);\n        if (symbols.length <= 0) this._transitions.delete(transitionKey);\n        return true;\n      }\n      else\n      {\n        return false;\n      }\n    }\n    //If deleting a all associated symbols...\n    else\n    {\n      //Update symbol counts...\n      for(const symbol of symbols)\n      {\n        this._decrSymbolCount(symbol);\n      }\n\n      //Remove transition\n      this._transitions.delete(transitionKey);\n      return true;\n    }\n  }\n\n  hasTransition(from, to, symbol=null)\n  {\n    const transitionKey = from.getStateID() + \"->\" + to.getStateID();\n    if (!this._transitions.has(transitionKey)) return false;\n    //Not checking for specific symbols...\n    if (!symbol) return true;\n\n    //Find the symbol...\n    return this._transitions.get(transitionKey).hasSymbol(symbol);\n  }\n\n  getTransitionSymbols(from, to)\n  {\n    const transitionKey = from.getStateID() + \"->\" + to.getStateID();\n    if (!this._transitions.has(transitionKey)) return null;\n    return this._transitions.get(transitionKey).getSymbols();\n  }\n\n  getTransitions() { return this._transitions.values(); }\n\n  _incrSymbolCount(symbol)\n  {\n    //Don't add empty symbol to the alphabet\n    if (symbol === FSA.EMPTY_SYMBOL) return;\n\n    const symbolCount = this._alphabet.get(symbol) || 0;\n    this._alphabet.set(symbol, symbolCount + 1);\n  }\n\n  _decrSymbolCount(symbol)\n  {\n    if (!this._alphabet.has(symbol)) throw new Error(\"Unable to find valid transition symbol in alphabet\");\n\n    //Empty symbol is not in the alphabet\n    if (symbol === FSA.EMPTY_SYMBOL) return;\n\n    const symbolCount = this._alphabet.get(symbol);\n    //Delete the symbol, since it is no longer used...\n    if (symbolCount <= 1)\n    {\n      if (!this.isCustomSymbol(symbol))\n      {\n        //Regular symbols are removed if unused...\n        this._alphabet.delete(symbol);\n      }\n      else\n      {\n        //Custom symbols stay in the alphabet, even if unused...\n        this._alphabet.set(symbol, 0);\n      }\n    }\n    else\n    {\n      //Still being used by someone...\n      this._alphabet.set(symbol, symbolCount - 1);\n    }\n  }\n\n  changeSymbol(symbol, newSymbol)\n  {\n    if (symbol === FSA.EMPTY_SYMBOL) throw new Error(\"Cannot change the empty symbol\");\n    if (newSymbol === FSA.EMPTY_SYMBOL) throw new Error(\"Cannot change to the empty symbol\");\n    if (this._alphabet.has(newSymbol)) throw new Error(\"Cannot change symbol to another existing symbol\");\n\n    for(const transition of this._transitions.values())\n    {\n      const symbols = transition.getSymbols();\n      const index = symbols.indexOf(symbol);\n\n      //Change the symbol from the transition\n      if (index >= 0)\n      {\n        symbols[index] = newSymbol;\n      }\n    }\n\n    //Exchange symbol counts...\n    const count = this._alphabet.get(symbol);\n    this._alphabet.set(newSymbol, count);\n    this._alphabet.delete(symbol);\n\n    //Check if custom symbol...\n    if (this._customSymbols.has(symbol))\n    {\n      this._customSymbols.delete(symbol);\n      this._customSymbols.add(newSymbol);\n    }\n  }\n\n  removeSymbol(symbol)\n  {\n    const cache = [];\n    for(const [key, transition] of this._transitions.entries())\n    {\n      const symbols = transition.getSymbols();\n      const index = symbols.indexOf(symbol);\n\n      //Delete the symbol from the transition\n      if (index >= 0)\n      {\n        symbols.splice(index, 1);\n\n        //If no more symbols, make sure to delete it from the map later...\n        if (symbols.length <= 0)\n        {\n          cache.push(key);\n        }\n      }\n    }\n\n    //Delete any transitions that have no more symbols...\n    for(const transitionKey of cache)\n    {\n      this._transitions.delete(transitionKey);\n    }\n\n    //Remove from alphabet if possible...\n    if (symbol !== FSA.EMPTY_SYMBOL)\n    {\n      if (this._customSymbols.has(symbol))\n      {\n        this._alphabet.set(symbol, 0);\n      }\n      else\n      {\n        this._alphabet.delete(symbol);\n      }\n    }\n  }\n\n  setCustomSymbol(symbol, custom=true)\n  {\n    if (symbol === FSA.EMPTY_SYMBOL) throw new Error(\"Cannot change the empty symbol as a custom symbol\");\n\n    if (custom)\n    {\n      if (!this._customAlphabet.has(symbol))\n      {\n        this._customAlphabet.add(symbol);\n\n        //Add symbol to alphabet if missing...\n        if (!this._alphabet.has(symbol)) this._alphabet.set(symbol, 0);\n      }\n    }\n    else\n    {\n      if (this._customAlphabet.has(symbol))\n      {\n        this._customAlphabet.delete(symbol);\n\n        //If symbol is unused, delete it\n        if (this._alphabet.has(symbol) && this._alphabet.get(symbol) <= 0) this._alphabet.delete(symbol)\n      }\n    }\n  }\n\n  isCustomSymbol(symbol)\n  {\n    return this._customAlphabet.has(symbol);\n  }\n\n  getCustomSymbols()\n  {\n    return this._customSymbols;\n  }\n\n  isUsedSymbol(symbol)\n  {\n    return this._alphabet.has(symbol) && this._alphabet.get(symbol) > 0;\n  }\n\n  isSymbol(symbol)\n  {\n    return this._alphabet.has(symbol);\n  }\n\n  getAlphabet()\n  {\n    return this._alphabet.keys();\n  }\n\n  setStartState(state)\n  {\n    const stateID = state.getStateID();\n    if (!this._states.has(stateID))\n    {\n      //Add it to the state set\n      this._states.set(stateID, state);\n    }\n    this._startState = state;\n  }\n\n  isStartState(state) { return this._startState === state; }\n\n  getStartState() { return this._startState; }\n\n  setFinalState(state, final=true)\n  {\n    //Make final\n    if (final)\n    {\n      //If missing from state set, add it in...\n      if (!this._states.has(state.getStateID()))\n      {\n        this.addState(state);\n      }\n\n      this._finalStates.add(state);\n    }\n    else\n    {\n      //If missing from state set, it would be effectively the same thing as\n      //calling addState(state). So due to ambiguity, don't do it.\n      if (!this._states.has(state.getStateID())) throw new Error(\"Trying to change final for missing state \\'\" + state.getStateLabel() + \"\\'\");\n\n      this._finalStates.delete(state);\n    }\n  }\n  isFinalState(state) { return this._finalStates.has(state); }\n  getFinalStates() { return this._finalStates; }\n\n  doTransition(state, symbol, dst=[])\n  {\n    if (!state) return dst;\n    if (!this._states.has(state.getStateID())) throw new Error(\"Unable to find source state with id \\'\" + state.getStateID() + \"\\'\");\n\n    if (!symbol) symbol = FSA.EMPTY_SYMBOL;\n\n    const fromTransitionKey = state.getStateID() + \"->\";\n    for(const key of this._transitions.keys())\n    {\n      if (key.startsWith(fromTransitionKey))\n      {\n        const transition = this._transitions.get(key);\n        if (transition.hasSymbol(symbol))\n        {\n          dst.push(transition.getDestinationState());\n\n          //There will only ever be 1 transition for deterministic machines\n          if (this._deterministic) return dst;\n        }\n      }\n    }\n    return dst;\n  }\n\n  doTerminalTransition(state, symbol, dst=[])\n  {\n    if (!state) return dst;\n    if (!this._states.has(state.getStateID())) throw new Error(\"Unable to find source state with id \\'\" + state.getStateID() + \"\\'\");\n\n    if (!symbol) symbol = FSA.EMPTY_SYMBOL;\n\n    const fromTransitionKey = state.getStateID() + \"->\";\n    for(const key of this._transitions.keys())\n    {\n      if (key.startsWith(fromTransitionKey))\n      {\n        const transition = this._transitions.get(key);\n        if (transition.hasSymbol(symbol))\n        {\n          const toState = transition.getDestinationState();\n          const result = this.doClosureTransition(toState);\n          for(const s of result)\n          {\n            if (!dst.includes(s)) dst.push(s);\n          }\n        }\n      }\n    }\n\n    return dst;\n  }\n\n  doClosureTransition(state, dst=[])\n  {\n    if (!state) return dst;\n\n    dst.push(state);\n    for(let i = 0; i < dst.length; ++i)\n    {\n      const transitions = this.getOutgoingTransitions(dst[i]);\n      for(const transition of transitions)\n      {\n        if (transition[SYMBOL_INDEX] === FSA.EMPTY_SYMBOL)\n        {\n          const toState = transition[TO_STATE_INDEX];\n          if (!dst.includes(toState))\n          {\n            dst.push(toState);\n          }\n        }\n      }\n    }\n    return dst;\n  }\n\n  getOutgoingTransitions(state, dst=[])\n  {\n    if (!state) return dst;\n    if (!this._states.has(state.getStateID())) throw new Error(\"Unable to find source state with id \\'\" + state.getStateID() + \"\\'\");\n\n    const fromTransitionKey = state.getStateID() + \"->\";\n    for(const key of this._transitions.keys())\n    {\n      if (key.startsWith(fromTransitionKey))\n      {\n        const transition = this._transitions.get(key);\n        const symbols = transition.getSymbols();\n        for(const symbol of symbols)\n        {\n          dst.push([state, symbol, transition.getDestinationState()]);\n        }\n      }\n    }\n\n    return dst;\n  }\n}\nFSA.EMPTY_SYMBOL = \"&empty\";\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FSA);\n\n\n//# sourceURL=webpack:///./src/app/modules/fsa/machine/FSA.js?");

/***/ }),

/***/ "./src/app/modules/fsa/machine/convertFSA.js":
/*!***************************************************!*\
  !*** ./src/app/modules/fsa/machine/convertFSA.js ***!
  \***************************************************/
/*! exports provided: convertToNFA, convertToDFA */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertToNFA\", function() { return convertToNFA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertToDFA\", function() { return convertToDFA; });\n/* harmony import */ var modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules/fsa/machine/FSA.js */ \"./src/app/modules/fsa/machine/FSA.js\");\n\n\nfunction convertToNFA(fsa, dst=new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](false))\n{\n  if (!fsa.isDeterministic())\n  {\n    dst.copy(fsa);\n    return dst;\n  }\n\n  dst.setDeterministic(false);\n  return dst;\n}\n\nfunction convertToDFA(fsa, dst=new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](true))\n{\n  if (fsa.isDeterministic())\n  {\n    dst.copy(fsa);\n    return dst;\n  }\n\n  dst.setDeterministic(true);\n\n  const startState = fsa.getStartState();\n\n  const dfaData = {\n    nfaSource: fsa,\n    //To keep track of dfa states in terms of nfa sets\n    dfaStateMap: new Map(),\n    //Array of final dfa states\n    dfaFinalStates: [],\n    //To keep track of dfa transitions in terms of dfa states\n    dfaTransitionMap: new Map(),\n    //The resultant dfa start state\n    dfaStartState: null,\n    //The trap state for all missing transitions\n    dfaTrapState: null\n  };\n\n  //Make new DFA start state\n  const startStatesByClosure = fsa.doClosureTransition(startState);\n  dfaData.dfaStartState = getDFAStateFromNFAStates(startStatesByClosure, dfaData);\n  dfaData.dfaTrapState = getDFAStateFromNFAStates([], dfaData);\n\n  //For every state from the NFA's powerset, add it to DFA with correct transitions\n  const statePowerSet = getPowerSetOfStates(fsa.getStates());\n  for(const nfaStates of statePowerSet)\n  {\n    //As long as it is not the empty set...\n    if (nfaStates.length > 0)\n    {\n      expandNFAStatesToDFA(nfaStates, dfaData);\n    }\n  }\n\n  //Make sure any unused symbols are added as transitions for every state...\n  for(const dfaState of dfaData.dfaStateMap.values())\n  {\n    for(const symbol of fsa.getAlphabet())\n    {\n      //If transition for symbol does not exist...\n      const dfaTransitionKey = getDFATransitionKeyFromDFAStateAndSymbol(dfaState, symbol, dfaData);\n      if (!dfaData.dfaTransitionMap.has(dfaTransitionKey))\n      {\n        dfaData.dfaTransitionMap.set(dfaTransitionKey, [dfaState, symbol, dfaData.dfaTrapState]);\n      }\n    }\n  }\n\n  //Compiled dfa data to dst\n  dst.clear();\n  //Add states\n  for(const dfaState of dfaData.dfaStateMap.values())\n  {\n    dst.addState(dfaState);\n  }\n\n  //Set start state\n  dst.setStartState(dfaData.dfaStartState);\n  //Set final states\n  for(const finalState of dfaData.dfaFinalStates)\n  {\n    dst.setFinalState(finalState);\n  }\n  //Add transitions (will also add any symbols used to alphabet)\n  for(const transition of dfaData.dfaTransitionMap.values())\n  {\n    dst.addTransition(transition[0], transition[2], transition[1]);\n  }\n  return dst;\n}\n\nfunction expandNFAStatesToDFA(nfaStates, dfaData)\n{\n  let fromDFAState = getDFAStateFromNFAStates(nfaStates, dfaData);\n  let dfaState = null;\n\n  let nfaTerminals = [];\n\n  for(const symbol of dfaData.nfaSource.getAlphabet())\n  {\n    //Get all closed reachable states...\n    for(const fromNFAState of nfaStates)\n    {\n      dfaData.nfaSource.doTerminalTransition(fromNFAState, symbol, nfaTerminals);\n    }\n\n    //If has reachable states...\n    if (nfaTerminals.length > 0)\n    {\n      dfaState = getDFAStateFromNFAStates(nfaTerminals, dfaData);\n\n      //Create transition for reachable state\n      //Should guarantee to be unique for state and symbol pair\n      const dfaTransitionKey = getDFATransitionKeyFromDFAStateAndSymbol(fromDFAState, symbol, dfaData);\n      dfaData.dfaTransitionMap.set(dfaTransitionKey, [fromDFAState, symbol, dfaState]);\n    }\n\n    //Reset list\n    nfaTerminals.length = 0;\n  }\n}\n\nfunction getNFAStateKeyFromNFAStates(nfaStates, dfaData)\n{\n  let result = \"\";\n  for(const nfaState of dfaData.nfaSource.getStates())\n  {\n    if (nfaStates.includes(nfaState))\n    {\n      result += \"x\";\n    }\n    else\n    {\n      result += \"-\";\n    }\n  }\n  return result;\n}\n\nfunction getDFATransitionKeyFromDFAStateAndSymbol(dfaState, symbol, dfaData)\n{\n  return dfaState.getStateID() + \";\" + symbol;\n}\n\nfunction getDFAStateFromNFAStates(nfaStates, dfaData)\n{\n  const nfaStateKey = getNFAStateKeyFromNFAStates(nfaStates, dfaData);\n  let result = dfaData.dfaStateMap.get(nfaStateKey);\n\n  //If it doesn't exist, create it...\n  if (!result)\n  {\n    let final = false;\n    //Compute the label from nfa states in set notation...\n    let dfaStateLabel = \"{\";\n    for(const state of nfaStates)\n    {\n      if (dfaStateLabel.length > 1)\n      {\n        dfaStateLabel += \",\";\n      }\n      dfaStateLabel += state.getStateLabel();\n\n      //Check if nfa state is final state...\n      if (!final)\n      {\n        final = dfaData.nfaSource.isFinalState(state);\n      }\n    }\n    dfaStateLabel += \"}\";\n\n    //Create the state\n    result = new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_0__[\"State\"](dfaStateLabel);\n    dfaData.dfaStateMap.set(nfaStateKey, result);\n\n    //If any nfa states is a final state, make dfa state final...\n    if (final)\n    {\n      dfaData.dfaFinalStates.push(result);\n    }\n  }\n\n  return result;\n}\n\nfunction getPowerSetOfStates(states)\n{\n  var result = [[]];\n\n  for(const state of states)\n  {\n    for(let i = 0, len = result.length; i < len; ++i)\n    {\n      result.push(result[i].concat(state));\n    }\n  }\n  return result;\n}\n\n\n//# sourceURL=webpack:///./src/app/modules/fsa/machine/convertFSA.js?");

/***/ }),

/***/ "./src/app/modules/fsa/machine/solveFSA.js":
/*!*************************************************!*\
  !*** ./src/app/modules/fsa/machine/solveFSA.js ***!
  \*************************************************/
/*! exports provided: solveFSA, solveNFAbyStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"solveFSA\", function() { return solveFSA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"solveNFAbyStep\", function() { return solveNFAbyStep; });\nconst MAX_COMPUTATION_STEPS = 1000;\n\nfunction solveFSA(fsa, input)\n{\n  if (typeof input === 'string') input = input[Symbol.iterator]();\n\n  if (fsa.isDeterministic())\n  {\n    //Solve if the DFA way...\n    let state = fsa.getStartState();\n    let symbol = null;\n\n    //Is testing null after assignment\n    while((symbol = input.next().value))\n    {\n      const states = fsa.doTransition(state, symbol);\n      if (states.length < 1) return false;\n      //DFA's should only return 1 output\n      state = states[0];\n    }\n    return fsa.isFinalState(state);\n  }\n  else\n  {\n    //Solve it the NFA way...\n    const cachedStates = [];\n    const cachedSymbols = [];\n\n    //Start with the start state...\n    const startState = fsa.getStartState();\n    //(index refers to the \"level\" of computation)\n    cachedStates.push({state: startState, index: 0});\n    //...and any state defined similarly by closure...\n    for(const relatedState of fsa.doClosureTransition(startState))\n    {\n      cachedStates.push({state: relatedState, index: 0});\n    }\n\n    const checkedStates = [];\n    //The next symbol to compute...\n    let symbol = null;\n\n    //Just to be safe from infinite loops...\n    let counter = 0;\n    while(cachedStates.length > 0)\n    {\n      symbol = input.next().value;\n      if (solveNFAbyStep(fsa, symbol, cachedStates, cachedSymbols, checkedStates))\n      {\n        return true;\n      }\n\n      //HACK: This is to stop any infinite loops! This should be fixed in the future!\n      ++counter;\n      if (counter > MAX_COMPUTATION_STEPS)\n      {\n        return false;\n      }\n    }\n\n    return false;\n  }\n}\n\n//TODO: When an empty transition occurs, it does a closure transition.\n//The closure chain will be stored as a group\n//Any future transitions must not re-enter the group\nfunction solveNFAbyStep(nfa, symbol, cachedStates, cachedSymbols, checkedStates)\n{\n  //initialize variables\n  let state = null;\n  let nextStates = [];\n  let nextIndex = 0;\n\n  if (symbol)\n  {\n    cachedSymbols.push(symbol);\n  }\n\n  for(const cstate of cachedStates)\n  {\n    state = cstate.state;\n    symbol = cstate.index < cachedSymbols.length ? cachedSymbols[cstate.index] : null;\n\n    if (symbol)\n    {\n      //Read to next state...\n      nextIndex = cstate.index + 1;\n      for(const nextState of nfa.doTerminalTransition(state, symbol))\n      {\n        nextStates.push({state: nextState, index: nextIndex});\n      }\n    }\n    else\n    {\n      if (nfa.isFinalState(state)) return true;\n      checkedStates.push(state);\n    }\n\n    //Read none to next state...\n    nextIndex = cstate.index;\n  }\n  cachedStates.length = 0\n  cachedStates.push(...nextStates);\n  return false;\n}\n\n\n//# sourceURL=webpack:///./src/app/modules/fsa/machine/solveFSA.js?");

/***/ }),

/***/ "./src/app/util/MathHelper.js":
/*!************************************!*\
  !*** ./src/app/util/MathHelper.js ***!
  \************************************/
/*! exports provided: guid, lerp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"guid\", function() { return guid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\nfunction guid()\n{\n  function s4()\n  {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n};\n\nfunction lerp(a, b, dt)\n{\n  return a * (1 - dt) + b * dt;\n};\n\n\n//# sourceURL=webpack:///./src/app/util/MathHelper.js?");

/***/ }),

/***/ "./src/debug/Tester.js":
/*!*****************************!*\
  !*** ./src/debug/Tester.js ***!
  \*****************************/
/*! exports provided: out, assertNotNull, assertEquals, assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"out\", function() { return out; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assertNotNull\", function() { return assertNotNull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assertEquals\", function() { return assertEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assert\", function() { return assert; });\nconst TEST_DIR = './src/debug/test/';\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n\n//For unit testing...\nlet testBuffer = [];\nlet testSuccesses = 0;\nlet testFailures = 0;\n\n//Start of program\n\nconsole.error(\"Preparing tests...\");\nconst files = fs.readdirSync(TEST_DIR);\nconsole.error(\"Starting \" + files.length + \" test(s)...\");\nconsole.error(\"- - - - - - - - - - - - - - - - - -\\n\");\nconst length = files.length;\nfor(let i = 0; i < length; ++i)\n{\n  const file = files[i];\n  let success = true;\n  console.error(\"== TEST #\" + i + \" == (\" + file + \")\");\n  {\n    try\n    {\n      testBuffer.length = 0;\n      testSuccesses = 0;\n      testFailures = 0;\n      __webpack_require__(\"./src/debug/test sync recursive ^\\\\.\\\\/.*$\")(\"./\" + file);\n      success = testFailures == 0;\n\n      if (!success)\n      {\n        while(testBuffer.length > 0)\n        {\n          const msg = testBuffer.shift();\n          console.error(msg);\n        }\n      }\n\n      ++testSuccesses;\n    }\n    catch(e)\n    {\n      console.error(e);\n      success = false;\n      ++testFailures;\n    }\n  }\n  const totals = \"(\" + testSuccesses + \"/\" + (testSuccesses + testFailures) + \")\";\n  console.error(\"== > \" + (success ? \"SUCCESS!\" : \"FAILURE!\") + \" \" + totals + \"\\n\");\n}\n\nconsole.error(\"- - - - - - - - - - - - - - - - - -\\n\");\n\n//End of program\nfunction format(element, depth=0)\n{\n  if (depth > 100) return element;\n\n  if (!element)\n  {\n    return element;\n  }\n  else if (typeof element === 'string')\n  {\n    return element;\n  }\n  else if (typeof element === 'object')\n  {\n    if (Array.isArray(element) || typeof element[Symbol.iterator] === 'function')\n    {\n      const className = element.constructor.name || \"Iterator\";\n      let msg = \"[\";\n      for(const e of element)\n      {\n        if (msg.length > 1) msg += \", \";\n        msg += format(e, depth + 1);\n      }\n      msg += \"]\";\n      return className + msg;\n    }\n    else\n    {\n      return JSON.stringify(element, null, 2);\n    }\n  }\n  else\n  {\n    return element;\n  }\n}\n\nfunction out(...msg)\n{\n  for(let i = 0, len = msg.length; i < len; ++i)\n  {\n    const element = msg[i];\n    msg[i] = format(element);\n  }\n  testBuffer.push(msg.join(\", \"));\n}\n\nfunction assertNotNull(value, msg=null)\n{\n  assert(value, \"null check - \" + msg);\n}\n\nfunction assertEquals(expected, value, msg=null)\n{\n  assert(value == expected, msg);\n}\n\nfunction assert(condition, msg=null)\n{\n  if (!condition)\n  {\n    ++testFailures;\n    testBuffer.push(\"= Failed\" + (msg ? \" - \" + msg : \".\"));\n  }\n  else\n  {\n    ++testSuccesses;\n    testBuffer.push(\"= Passed!\");\n  }\n}\n\n\n//# sourceURL=webpack:///./src/debug/Tester.js?");

/***/ }),

/***/ "./src/debug/test sync recursive ^\\.\\/.*$":
/*!**************************************!*\
  !*** ./src/debug/test sync ^\.\/.*$ ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./TestConvertToDFA\": \"./src/debug/test/TestConvertToDFA.mjs\",\n\t\"./TestConvertToDFA.mjs\": \"./src/debug/test/TestConvertToDFA.mjs\",\n\t\"./TestSolveDFA\": \"./src/debug/test/TestSolveDFA.mjs\",\n\t\"./TestSolveDFA.mjs\": \"./src/debug/test/TestSolveDFA.mjs\",\n\t\"./TestSolveNFA\": \"./src/debug/test/TestSolveNFA.mjs\",\n\t\"./TestSolveNFA.mjs\": \"./src/debug/test/TestSolveNFA.mjs\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/debug/test sync recursive ^\\\\.\\\\/.*$\";\n\n//# sourceURL=webpack:///./src/debug/test_sync_^\\.\\/.*$?");

/***/ }),

/***/ "./src/debug/test/TestConvertToDFA.mjs":
/*!*********************************************!*\
  !*** ./src/debug/test/TestConvertToDFA.mjs ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Tester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Tester.js */ \"./src/debug/Tester.js\");\n/* harmony import */ var modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules/fsa/machine/FSA.js */ \"./src/app/modules/fsa/machine/FSA.js\");\n/* harmony import */ var modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! modules/fsa/machine/solveFSA.js */ \"./src/app/modules/fsa/machine/solveFSA.js\");\n/* harmony import */ var modules_fsa_machine_convertFSA_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! modules/fsa/machine/convertFSA.js */ \"./src/app/modules/fsa/machine/convertFSA.js\");\n\n\n\n\n\n\n{\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Trying to convert an empty NFA machine...\");\n  const nfa = new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](false);\n  const dfa = Object(modules_fsa_machine_convertFSA_js__WEBPACK_IMPORTED_MODULE_3__[\"convertToDFA\"])(nfa, nfa);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](dfa && dfa.validate(), \"Empty machine is valid DFA.\");\n}\n\n{\n  //Try simplest machine\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Trying single state machine...\");\n  const nfa = new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](false);\n  const state0 = nfa.createState(\"q0\");\n  nfa.addTransition(state0, state0, \"0\");\n  nfa.addTransition(state0, state0, \"1\");\n  const dfa = Object(modules_fsa_machine_convertFSA_js__WEBPACK_IMPORTED_MODULE_3__[\"convertToDFA\"])(nfa, nfa);\n  const trapStates = nfa.getStatesByLabel(\"{}\");\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](trapStates && trapStates.length == 1, \"Trap state exists.\");\n  const trapState = trapStates[0];\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](dfa.getTransitions());\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](dfa && dfa.validate(), dfa.getErrors());\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Checking for states...\");\n  const states = Array.from(dfa.getStates());\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"States:\", states);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](2, states.length);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](dfa.hasStateWithLabel(\"{q0}\"));\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Checking for alphabet...\");\n  const alphabet = Array.from(dfa.getAlphabet());\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Alphabet:\", alphabet);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](2, alphabet.length);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](alphabet.includes(\"0\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](alphabet.includes(\"1\"));\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Checking for transitions...\");\n  const transitions = dfa.getTransitions();\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Transitions:\", transitions);\n  let q0 = dfa.getStatesByLabel(\"{q0}\");\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](q0.length == 1);\n  q0 = q0[0];\n  let result = dfa.doTransition(q0, \"0\");\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](result.length == 1);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](result[0].getStateLabel() == \"{q0}\");\n  result = dfa.doTransition(q0, \"1\");\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](result.length == 1);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](result[0].getStateLabel() == \"{q0}\");\n}\n\n{\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Trying another machine...\");\n  const nfa = new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](false);\n  const state0 = nfa.createState(\"q0\");\n  const state1 = nfa.createState(\"q1\");\n  nfa.addTransition(state0, state0, \"0\");\n  nfa.addTransition(state0, state0, \"1\");\n  nfa.addTransition(state0, state1, \"1\");\n  nfa.setFinalState(state1);\n  const result = Object(modules_fsa_machine_convertFSA_js__WEBPACK_IMPORTED_MODULE_3__[\"convertToDFA\"])(nfa, nfa);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](result && result.validate(), result.getErrors());\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Checking for states...\");\n  const states = result.getStates();\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"States:\", states);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"StartState:\", result.getStartState());\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"FinalStates:\", result.getFinalStates());\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Checking for alphabet...\");\n  const alphabet = result.getAlphabet();\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Alphabet:\", alphabet);\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Checking for transitions...\");\n  const transitions = result.getTransitions();\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Transitions:\", transitions);\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Testing by solving inputs...\");\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](!Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"0\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](!Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"1\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"111111111111\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"10000000001\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"0000000001\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"101010010010100101\"));\n}\n\n{\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Testing immediate moves...\");\n  const nfa = new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](false);\n  const state0 = nfa.createState(\"q0\");\n  const state1 = nfa.createState(\"q1\");\n  nfa.addTransition(state0, state0, \"0\");\n  nfa.addTransition(state0, state0, \"1\");\n  nfa.addTransition(state0, state1, \"1\");\n  nfa.addTransition(state0, state1, modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EMPTY_SYMBOL);\n  nfa.setFinalState(state1);\n  const result = Object(modules_fsa_machine_convertFSA_js__WEBPACK_IMPORTED_MODULE_3__[\"convertToDFA\"])(nfa, nfa);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](result && result.validate());\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Checking for states...\");\n  const states = result.getStates();\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"States:\", states);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"StartState:\", result.getStartState());\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"FinalStates:\", result.getFinalStates());\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Checking for alphabet...\");\n  const alphabet = result.getAlphabet();\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Alphabet:\", alphabet);\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Checking for transitions...\");\n  const transitions = result.getTransitions();\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Transitions:\", transitions);\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Testing by solving inputs...\");\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"0\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"1\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"111111111111\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"10000000001\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"0000000001\"));\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(result, \"101010010010100101\"));\n}\n\n{\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Trying recursive test...\");\n  const machine = new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n  const state0 = machine.createState(\"q0\");\n  const state1 = machine.createState(\"q1\");\n  machine.addTransition(state0, state1, \"1\");\n  machine.addTransition(state1, state0, \"0\");\n  machine.setStartState(state0);\n  machine.setFinalState(state0);\n  const result = Object(modules_fsa_machine_convertFSA_js__WEBPACK_IMPORTED_MODULE_3__[\"convertToDFA\"])(machine, machine);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](result && result.validate());\n}\n\n\n//# sourceURL=webpack:///./src/debug/test/TestConvertToDFA.mjs?");

/***/ }),

/***/ "./src/debug/test/TestSolveDFA.mjs":
/*!*****************************************!*\
  !*** ./src/debug/test/TestSolveDFA.mjs ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Tester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Tester.js */ \"./src/debug/Tester.js\");\n/* harmony import */ var modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules/fsa/machine/FSA.js */ \"./src/app/modules/fsa/machine/FSA.js\");\n/* harmony import */ var modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! modules/fsa/machine/solveFSA.js */ \"./src/app/modules/fsa/machine/solveFSA.js\");\n\n\n\n\n\n//Regexpr: 1*\n{\n  const machine = new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](true);\n  const state0 = machine.createState(\"q0\");\n  const state1 = machine.createState(\"q1\");\n  machine.addTransition(state0, state1, \"0\");\n  machine.addTransition(state0, state0, \"1\");\n  machine.addTransition(state1, state1, \"0\");\n  machine.addTransition(state1, state1, \"1\");\n  machine.setStartState(state0);\n  machine.setFinalState(state0);\n\n  //Make sure the DFA is a valid DFA\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"](machine.validate(), \"Machine is valid: \" + machine.getErrors());\n\n  //Should accept the empty string since start state is final state\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"\"), true, \"Machine accepts the empty string.\");\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Testing other input strings...\");\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"0\"), false);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"1\"), true);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"011111\"), false);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"11010101\"), false);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"1111\"), true);\n}\n\n\n//# sourceURL=webpack:///./src/debug/test/TestSolveDFA.mjs?");

/***/ }),

/***/ "./src/debug/test/TestSolveNFA.mjs":
/*!*****************************************!*\
  !*** ./src/debug/test/TestSolveNFA.mjs ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Tester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Tester.js */ \"./src/debug/Tester.js\");\n/* harmony import */ var modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules/fsa/machine/FSA.js */ \"./src/app/modules/fsa/machine/FSA.js\");\n/* harmony import */ var modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! modules/fsa/machine/solveFSA.js */ \"./src/app/modules/fsa/machine/solveFSA.js\");\n\n\n\n\n\n//Regex: 1*\n{\n  const machine = new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](false);\n  const state0 = machine.createState(\"q0\");\n  const state1 = machine.createState(\"q1\");\n  machine.addTransition(state0, state1, \"0\");\n  machine.addTransition(state0, state0, \"1\");\n  machine.addTransition(state1, state1, \"0\");\n  machine.addTransition(state1, state1, \"1\");\n  machine.setStartState(state0);\n  machine.setFinalState(state0);\n\n  //Should accept the empty string since start state is final state\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"\"), true, \"Machine accepts the empty string.\");\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Testing DFA-like NFA machine...\");\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"0\"), false);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"1\"), true);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"011111\"), false);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"11010101\"), false);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"1111\"), true);\n}\n\n{\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Testing NFA with immediate transitions...\");\n  const machine = new modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n  const state0 = machine.createState(\"q0\");\n  const state1 = machine.createState(\"q1\");\n  const state2 = machine.createState(\"q2\");\n  machine.addTransition(state0, state1, \"0\");\n  machine.addTransition(state0, state2, \"1\");\n  machine.addTransition(state1, state2, modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EMPTY_SYMBOL);\n  machine.addTransition(state1, state0, modules_fsa_machine_FSA_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EMPTY_SYMBOL);\n  machine.addTransition(state1, state1, \"0\");\n  machine.addTransition(state1, state1, \"1\");\n  machine.setStartState(state0);\n  machine.setFinalState(state2);\n\n  //Should accept the empty string since start state is final state\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"\"), false, \"Machine rejects the empty string.\");\n\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"out\"](\"Testing other input strings...\");\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"0\"), true);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"1\"), true);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"011111\"), true);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"11010101\"), false);\n  _Tester_js__WEBPACK_IMPORTED_MODULE_0__[\"assertEquals\"](Object(modules_fsa_machine_solveFSA_js__WEBPACK_IMPORTED_MODULE_2__[\"solveFSA\"])(machine, \"1111\"), false);\n}\n\n\n//# sourceURL=webpack:///./src/debug/test/TestSolveNFA.mjs?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ })

/******/ });